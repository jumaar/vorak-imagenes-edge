services:
  #--------------------------------------------------------------------------
  # SERVICIO 'NEVERA' - El cerebro del sistema
  #--------------------------------------------------------------------------
  nevera:
    # --- ¡CORRECCIÓN! ---
    # Añadimos la clave 'build' para decirle a Compose cómo construir la imagen.
    build: ./MODULO-NEVERA
    image: vorak-nevera:local # <-- Usaremos esta imagen local
    container_name: vorak-nevera
    restart: unless-stopped
    environment:
      # --- Variables de entorno para app.py ---
      # Leídas desde el archivo .env en la raíz del proyecto
      - FRIDGE_ID=${FRIDGE_ID}
      - BASE_BACKEND_URL=${BASE_BACKEND_URL}
      - FRIDGE_SECRET=${FRIDGE_SECRET} # Para pruebas locales, lo pasamos como variable
      - CAMERA_DEVICES=/dev/video0,/dev/video2 # IMPORTANTE: Ajusta esto a tus cámaras
      - BAUD_RATE=115200
    volumes:
      # Volumen para la base de datos de productos
      - nevera_db:/app/db
      # Volumen para guardar transacciones si no hay conexión
      - nevera_offline_queue:/app/offline_queue
      # Volumen para guardar imágenes de sesiones de baja confianza
      - nevera_review_queue:/app/review_queue
      # Volumen compartido para comunicar el estado al kiosko
      - fridge_status:/app/status
    devices:
      # --- Acceso al Hardware del Host ---
      # Permite al contenedor acceder a las cámaras
      - "/dev/video0:/dev/video0"
      - "/dev/video2:/dev/video2"
      # Permite al contenedor acceder al ESP32 (ajusta si es necesario)
      - "/dev/ttyUSB0:/dev/ttyUSB0"
    networks:
      - vorak-net

  #--------------------------------------------------------------------------
  # SERVICIO 'KIOSKO' - La interfaz de usuario web
  #--------------------------------------------------------------------------
  kiosko:
    # --- ¡CORRECCIÓN! ---
    # Añadimos la clave 'build' también para el servicio del kiosko.
    build: ./MODULO-KIOSKO
    image: vorak-kiosko:local # <-- Usaremos esta imagen local
    container_name: vorak-kiosko
    restart: unless-stopped
    ports:
      # Expone el puerto del servidor web para que el navegador del host pueda acceder
      - "5000:5000"
    environment:
      # Leídas desde el archivo .env en la raíz del proyecto
      - FRIDGE_ID=${FRIDGE_ID}
      - BASE_BACKEND_URL=${BASE_BACKEND_URL}
      - FRIDGE_SECRET=${FRIDGE_SECRET}
    volumes:
      # Volumen para la caché de medios y la playlist
      - kiosk_data:/app/data
      # Volumen compartido para leer el estado de la nevera
      - fridge_status:/app/status
    networks:
      - vorak-net

  #--------------------------------------------------------------------------
  # SERVICIO 'BACKUP' - Realiza copias de seguridad periódicas
  #--------------------------------------------------------------------------
  backup:
    image: alpine:latest
    container_name: vorak-backup
    restart: unless-stopped
    command: >
      /bin/sh -c "
        echo 'Contenedor de backup iniciado. El primer backup se ejecutará en 1 minuto...';
        sleep 60;
        while true; do
          /backup/backup.sh;
          echo 'Backup completado. Próxima ejecución en 24 horas.';
          sleep 86400;
        done
      "
    volumes:
      # Monta el script de backup dentro del contenedor
      - ./MODULO-BACKUP/backup.sh:/backup/backup.sh
      # Monta los volúmenes de origen (solo lectura para seguridad)
      - nevera_offline_queue:/backups/source/offline_queue:ro
      - nevera_review_queue:/backups/source/review_queue:ro
      # Monta el volumen de destino donde se guardarán los backups
      - backup_data:/backups/destination
    networks:
      - vorak-net

  #--------------------------------------------------------------------------
  # STACK DE MONITOREO - Portainer, Prometheus, etc.
  #--------------------------------------------------------------------------
  portainer:
    image: portainer/portainer-ce:latest
    container_name: vorak-portainer
    command: -H unix:///var/run/docker.sock
    ports:
      - "9443:9443"
      - "8000:8000"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - portainer_data:/data
    restart: unless-stopped
    networks:
      - vorak-net

  prometheus:
    # --- ¡CORRECCIÓN! ---
    # Usamos 'build' para crear una imagen personalizada que incluya 'envsubst'.
    build:
      context: ./MODULO-MONITORING
      dockerfile: prometheus.Dockerfile
    container_name: vorak-prometheus
    ports:
      # Mapea el puerto 9090 del host al puerto 9090 del contenedor
      - "9090:9090"
    environment:
      # --- ¡CORRECCIÓN! ---
      # Pasamos las variables del .env para que se sustituyan en prometheus.yml
      - GRAFANA_CLOUD_PROMETHEUS_URL=${GRAFANA_CLOUD_PROMETHEUS_URL}
      - GRAFANA_CLOUD_PROMETHEUS_USER=${GRAFANA_CLOUD_PROMETHEUS_USER}
    volumes:
      - ./MODULO-MONITORING/prometheus.dev.yml:/etc/prometheus/prometheus.yml
      - /var/run/docker.sock:/var/run/docker.sock:ro
    secrets:
      # --- ¡CORRECCIÓN! ---
      # Montamos el secreto para que esté disponible en /run/secrets/
      - grafana_cloud_prometheus_api_key
    # --- ¡CORRECCIÓN! ---
    # La lógica del entrypoint ahora está en el Dockerfile.
    # Solo pasamos los argumentos al comando principal.
    command:
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/usr/share/prometheus/console_libraries'
      - '--web.console.templates=/usr/share/prometheus/consoles'
    restart: unless-stopped
    networks:
      - vorak-net

  promtail:
    # --- ¡CORRECCIÓN! ---
    # Usamos 'build' para crear una imagen personalizada que incluya 'envsubst'.
    build:
      context: ./MODULO-MONITORING
      dockerfile: promtail.Dockerfile
    container_name: vorak-promtail
    environment:
      # --- ¡CORRECCIÓN! ---
      # Pasamos las variables del .env para que se sustituyan en promtail.dev.yml
      - GRAFANA_CLOUD_LOKI_URL=${GRAFANA_CLOUD_LOKI_URL}
      - GRAFANA_CLOUD_LOKI_USER=${GRAFANA_CLOUD_LOKI_USER}
    volumes:
      - ./MODULO-MONITORING/promtail.dev.yml:/etc/promtail/config.yml
      - /var/log:/var/log:ro
      - /var/lib/docker/containers:/var/lib/docker/containers:ro
      - /var/run/docker.sock:/var/run/docker.sock:ro
    secrets:
      # --- ¡CORRECCIÓN! ---
      # Montamos el secreto para que esté disponible en /run/secrets/
      - grafana_cloud_loki_api_key
    # --- ¡CORRECCIÓN! ---
    # La lógica del entrypoint ahora está en el Dockerfile.
    # El comando ya se define en el script de entrypoint.
    restart: unless-stopped
    networks:
      - vorak-net

  cadvisor:
    image: gcr.io/cadvisor/cadvisor:v0.47.2
    container_name: vorak-cadvisor
    volumes:
      - /:/rootfs:ro
      - /var/run:/var/run:rw
      - /sys:/sys:ro
      - /var/lib/docker/:/var/lib/docker:ro
    restart: unless-stopped
    networks:
      - vorak-net

#--------------------------------------------------------------------------
# RED Y VOLÚMENES
#--------------------------------------------------------------------------
secrets:
  # --- ¡CORRECCIÓN! ---
  # Definimos los secretos para que Docker Compose los lea desde el archivo .env
  # Esto emula el comportamiento de 'docker secret create' para desarrollo.
  grafana_cloud_prometheus_api_key:
    environment: GRAFANA_CLOUD_PROMETHEUS_API_KEY
  grafana_cloud_loki_api_key:
    environment: GRAFANA_CLOUD_LOKI_API_KEY

#--------------------------------------------------------------------------
# RED Y VOLÚMENES
#--------------------------------------------------------------------------
networks:
  vorak-net:
    driver: bridge

volumes:
  nevera_db:
  nevera_offline_queue:
  nevera_review_queue:
  kiosk_data:
  fridge_status: # Volumen clave para la comunicación entre servicios nevera y kiosko
  portainer_data: # Volumen para persistir los datos de Portainer (si se despliega localmente)
  backup_data: # Volumen para almacenar los archivos de backup